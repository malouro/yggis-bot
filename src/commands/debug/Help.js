import Command from '../../classes/Command';

export default class Help extends Command {
	constructor({ t } = { t: () => null }) {
		super({
			name: 'Help',
			category: 'debug',
			aliases: [],
			description:
				'Help menus, support and information. Find out what commands exist and how to use them.',
			usage: {
				args: [
					{
						name: 'command',
						description: 'Get help on how to use a specific command.',
						chainable: false,
					},
					{
						name: 'commandCategory',
						description:
							'Learn more about commands available under a given category.',
						chainable: false,
					},
				],
			},
		});

		this.t = t;
		this.translationKey = 'help';

		this.name = this.t('COMMANDS', this.translationKey, 'name') || this.name;
		this.description =
			this.t('COMMANDS', this.translationKey, 'description') ||
			this.description;

		this.messageOutput = '';
	}

	getCommandArgs(command) {
		const { usage, name: commandName, translationKey } = command;
		const usageTranslations =
			this.t('COMMANDS', translationKey, 'usage') ||
			this.t('COMMANDS', commandName, 'usage');
		const chainableArgs = [];
		const nonChainableArgs = [];

		usage.args.forEach(arg => {
			if (arg.chainable) {
				chainableArgs.push(
					usageTranslations && usageTranslations[arg.name]
						? usageTranslations[arg.name].name
						: arg.name
				);
			} else {
				nonChainableArgs.push(
					usageTranslations && usageTranslations[arg.name]
						? usageTranslations[arg.name].name
						: arg.name
				);
			}
		});

		return {
			chainableArgs,
			nonChainableArgs,
		};
	}

	getCommandArgsUsage(chainableArgs, nonChainableArgs) {
		let argsUsageOutput = '';

		if (nonChainableArgs.length > 0) {
			argsUsageOutput = argsUsageOutput.concat(
				'`<',
				nonChainableArgs.join('|'),
				'>`'
			);
		}

		if (chainableArgs.length > 0) {
			argsUsageOutput = argsUsageOutput.concat(
				nonChainableArgs.length > 0 ? ' ' : '',
				'`(',
				chainableArgs.join(', '),
				')`'
			);
		}

		return argsUsageOutput;
	}

	getDetailedArgsDescription(args, commandName) {
		let argsDetailsOutput = '';

		const translations = this.t(
			'COMMANDS',
			commandName.toLocaleLowerCase(),
			'usage'
		);
		const missingDescription = this.t(
			'COMMON',
			'commands',
			'missingArgumentDescription'
		);

		args.forEach((arg, index) => {
			const description =
				(translations &&
					translations[arg.name] &&
					translations[arg.name].description) ||
				arg.description ||
				missingDescription;
			const argName =
				(translations &&
					translations[arg.name] &&
					translations[arg.name].name) ||
				arg.name;
			const argUsage =
				(translations &&
					translations[arg.name] &&
					translations[arg.name].usage) ||
				arg.usage;

			argsDetailsOutput = argsDetailsOutput.concat(
				index === 0 ? '\n' : '\n\n',
				`\`${argName}\``,
				'\n',
				description,
				arg.usage ? `${'\n'.repeat(2)}\`${argUsage}\`` : ''
			);
		});

		return argsDetailsOutput;
	}

	buildMainHelpMenu({ commandPrefix, name: botName }, categories) {
		const translate = key => this.t('COMMANDS', this.translationKey, key);
		const { chainableArgs, nonChainableArgs } = this.getCommandArgs(this);

		const mainMenuHeader =
			translate('mainMenuHeader')(botName) || `**__${botName} Help Menu__**`;
		const helpCommandUsage = String.prototype.concat(
			`\`${commandPrefix}${this.name.toLocaleLowerCase()}\``,
			' ',
			`${this.getCommandArgsUsage(chainableArgs, nonChainableArgs)}`
		);
		const commandsHeader =
			translate('mainMenuCommandsHeader') || '**Commands**';
		const categoryHeader = category =>
			translate('mainMenuCategoryHeader')(category.name) ||
			`> ${category.name} commands\n`;
		const commandList = categories
			.map(category =>
				categoryHeader(category).concat(
					category.commands
						.map(command => `\`${commandPrefix}${command}\``)
						.join(', ')
				)
			)
			.join('\n\n');

		return [
			mainMenuHeader,
			'',
			helpCommandUsage,
			'',
			commandsHeader,
			'',
			commandList,
		].join('\n');
	}

	/**
	 * This will build the text to display for any given Command's help menu
	 *
	 * The information here is generated by the Commands predefined `description`, `usage`, and `args` usage
	 */
	buildCommandHelpMenu({ commandPrefix }, command, invalidUsage = false) {
		const { usage, name, translationKey } = command;
		const { chainableArgs, nonChainableArgs } = this.getCommandArgs(command);

		const translate = key => this.t('COMMANDS', name.toLocaleLowerCase(), key);

		/* Get all appropriate text to display */
		const description = translate('description') || command.description;
		const title =
			(typeof this.t('COMMANDS', translationKey, 'commandHeader') ===
				'function' &&
				this.t('COMMANDS', translationKey, 'commandHeader')(name)) ||
			`**${name} Command**`;
		const commandUsage = String.prototype.concat(
			`\`${commandPrefix}${name.toLocaleLowerCase()}\``,
			' ',
			`${this.getCommandArgsUsage(chainableArgs, nonChainableArgs)}`
		);
		const invalidUsageText =
			(typeof this.t('COMMANDS', translationKey, 'invalidCommandUsage') ===
				'function' &&
				this.t(
					'COMMANDS',
					translationKey,
					'invalidCommandUsage'
				)(commandPrefix, command.name.toLocaleLowerCase())) ||
			`Invalid \`${commandPrefix}${command.name.toLocaleLowerCase()}\` usage.\n`;
		const missingDescriptionText =
			this.t('COMMON', 'commands', 'missingArgumentDescription') ||
			'(Missing description.)';
		const descriptionText = `${title}\n\n${description ||
			missingDescriptionText}\n`;

		return [
			invalidUsage ? invalidUsageText : descriptionText,
			'',
			commandUsage,
			'',
			this.getDetailedArgsDescription(usage.args, translationKey || name),
		].join('\n');
	}

	buildCategoryHelpMenu({ commandPrefix }, category) {
		const { name: categoryName, description, commands } = category;
		const translations = this.t(
			'COMMANDS',
			'categories',
			categoryName.toLocaleLowerCase()
		);
		const name = translations ? translations.name : categoryName;
		const title =
			(typeof this.t('COMMANDS', this.translationKey, 'categoryHeader') ===
				'function' &&
				this.t('COMMANDS', this.translationKey, 'categoryHeader')(name)) ||
			`**${name} Commands**`;

		const commandList = commands
			.map(command => `\`${commandPrefix}${command}\``)
			.join(', ');

		const descriptionText =
			translations && translations.description
				? `\n${translations.description}\n`
				: `\n${description}\n`;

		// prettier-ignore
		return [
			title,
			description ? descriptionText : '',
			commandList
		].join('\n');
	}

	/* Determine from the arguments what to actually run */
	preAction({ args, bot }) {
		if (args.length === 1) {
			// !help (no args)
			/* eslint-disable no-underscore-dangle */
			this.messageOutput = this.buildMainHelpMenu(bot, bot._commandCategories);
		} else if (bot.commands.has(args[1])) {
			// !help <command>
			this.messageOutput = this.buildCommandHelpMenu(
				bot,
				bot.commands.get(args[1].toLocaleLowerCase())
			);
		} else if (bot._commandCategories.has(args[1])) {
			// !help <category>
			this.messageOutput = this.buildCategoryHelpMenu(
				bot,
				bot._commandCategories.get(args[1].toLocaleLowerCase())
			);
		} else {
			// !help {invalidUsage}
			this.messageOutput = this.buildCommandHelpMenu(bot, this, true);
		}
		/* eslint-enable no-underscore-dangle */
	}

	action({ message }) {
		message.channel.send(this.messageOutput);
	}
}
